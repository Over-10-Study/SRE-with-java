## 6.2 릴리스 버전 관리

소프트웨어 전달 라이프 사이클에서 아티팩트 저장소의 관여 시점은 CI 프로세스 직후이다. (아티팩트는 산출물? 정도로 해석하면 될 것 같다.)

JAR, 컨테이너 이미지, 데비안/RPM 등의 아티팩트 유형이 달라도 버전 관리 체계를 수립할 때 불변 버전이라는 최종 목표는 동일하다.

### 6.2.1 메이븐 저장소

일반적으로 릴리스 저장소와 스냅샷 저장소로 구분한다.

릴리스 저장소 경로는 저장소의 기본 URL, 아티팩트 그룹, 아티팩트, 버전으로 구성된다.

![image-20220815204125680](/Users/smjeon/Library/Application Support/typora-user-images/image-20220815204125680.png)

메이븐 스냅샷 저장소는 `implementation io.rsocket:rsocket-core:1.0.0-RC7-SNAPSHOT` 과 같이 SNAPSHOT이 붙는다.

![image-20220815204613905](/Users/smjeon/Library/Application Support/typora-user-images/image-20220815204613905.png)

여기서 보면 SNAPSHOT 이라는 의존성은 불변 설정이 아니다. 배포할 때 SNAPSHOT이 붙은 의존성을 지정했을 때, 설정 당시의 버전과 배포 시점의 버전이 일치하지 않을 수 있다.

가급적이면 저수준 환경에서 스냅샷 버전으로 테스트하지 않는 것이 바람직하다. 사용한다면, 프로모션으로 승격 시킬 때 릴리스 버전으로 다시 빌드 해야한다.

마이크로서비스 버전 관리에 대한 모든 논의는 다음 두가지 대원칙으로 요약된다.

#### 고유성 - 소스 코드와 의존성의 조합을 고유하게 식별하는 버전 번호

#### 불변성 - 저장소에 지정된 아티팩트 버전이 다른 버전으로 덮어씌워지지 않음

메이븐 스냅샷은 고유성 원칙을 만족하지 못한다.

### 6.2.2 빌드 도구를 이용한 릴리스 버전 관리

넷플릭스 네뷸라 제품군 중 릴리스 플러그인은 위의 두 원칙을 모두 만족하는 버전 관리 워크플로우를 제공한다. `final`, `candidate`, `devSnapshot`등의 gradle task를 포함한다.

마이크로서비스의 버전 관리는 저수준 환경에서 실행되던 코드를 언제든지 프로덕션에 승격할 수 있다. 그래서 이런 승격이 일어날 때마다(배포 파이프라인 마지막에) 마이너 릴리스 단계를 올리고, 버전명을 태그로 지정하여 다음 주기에 대비한다.

한 주기는 배포가 최종적으로 프로덕션에 승격되기 전까지 여러 번 수행될 수도 있고, 저수준 환경에서 성공했던 모든 배포가 프로덕션에 승격됐고, 모든 테스트 자동화도 통과했다는 것을 의미한다.

네뷸라 릴리스 플러그인은 코드를 빌드할 때마다 저장소의 최신태그를 확인하고, 다음 마이너 버전으로 스냅샷을 생성한다. 그리고 CI는 네뷸라 릴리스 플러그인을 사용해서 빌드를 실행하고, 그 결과물로 스냅샷이 생성된다. 그 후 프로덕션으로 승격될 때까지는 마이너 리비전은 일관성을 유지하고, 승격이 완료되면 CD 자동화 시스템이 저장소에 태그를 지정한다.

테스트를 통과한 모든 커밋을 프로덕션으로 배포하는 CD pipeline도 있을 수 있다. 그러나 결국에는 조직에 맞게 잘 사용해야한다.

## 6.5 의존성 관리

### 6.5.1 버전 불일치

의존성 집합 중 일부 버전이 충돌하면 제대로 동작하지 않을 수 있다. 만약 스프링부트 버전을 업그레이드 한다고 했을 때, 여기에 포함된 잭슨의 버전도 올라간다. 이런 모듈들을 사용하는 다른 마이크로서비스가 있다면, 스프링부트 버전 업그레이드 시에 문제가 될 수 있다.

### 6.5.2 동적 버전 제약

gradle은 latest.release 나 2.10.+ 처럼, maven은 RELEASE나 (,2.11.0] 처럼 엉성한 방식으로 버전 범위를 지정할 수 있다.

**+ 선택자는 지양하는 것이 좋다.** 사전 순서로 버전을 정렬하기 때문에 2.10.9는 2.10.10 이후 버전으로 간주된다.

그리고 latest.release 나 RELEASE는 릴리스 버전과 후보 버전을 구분하지 못한다. 유명 라이브러리들도 latest.release로 2.11.0.rc1을 게시하고, 2.10.0.pr1 을 게시하기도 한다. 결과적으로 둘 다 latest.release 라는 의미에 부합하지 않는다.

위와 같은 릴리스 후보(rc~, pr~) 들은 빌드 설정에서 패턴을 이용하여 차단할 수 있다. (아래 예시)

```groovy
repositories {
  mavenCentral {
    content {
      excludeVersionByRegex("com\\.fasterxml\\.jackson\\..*", ".*", ".*rc")
    }
  }
  mavenCentral {
    content {
      includeVersionByRegex("com\\.fasterxml\\.jackson\\..*", ".*", "(\\d+\\.)*\\d+")
    }
  }
}
```

### 6.5.3 미사용 의존성

미사용 의존성은 마이크로서비스의 크기를 불필요하게 키운다.(사소하지만) 그리고 사용하는 라이브러리의 취약점이 밝혀졌을 때, 이 라이브러리를 사용하지 않는 마이크로서비스에도 영향이 있을 수 있다.

미사용 의존성은 네뷸라 린트 플러그인에서 자동으로 감지하고 제거할 수 있다.

### 6.5.4 명시적으로 사용된 미선언 의존성

네뷸라 린트 플러그인이 선언되지 않은 의존성도 자동으로 추가하고 할 수 있다는 뜻인 것 같은데, 무슨 뜻인지 잘 모르겠다.

## 7.7 호출 복원 패턴

과거의 성능은 결코 미래의 결과를 보장해주지 않는다.

서비스 과부하는 완전한 중단을 야기하고, MSA의 모든 계층은 이러한 과부하로부터 보호 받아야한다.

### 배압

배압은 서빙 시스템에서 요청 시스템을 향한 장애 신호 체계, 요청 시스템이 자신과 서빙 시스템의 과부하를 막기 위해 도입하는 방지책이다. 과부하 및 시스템 장애 기간 동안 가용 리소스를 제한 한다는 의미이다.

일반적으로 배압 기능은 리소스가 제한되거나 장애가 발생했을 때, 사용자에게 메시지나 에러를 통해 통보하고, 동시에 메트릭이 증가한다.

호출 하는 쪽은 재시도, 비율 제한, 벌크헤드, 서킷 브레이커를 조합해서 복원력을 높일 수 있다.

### 7.7.1 재시도

말 그대로 재시도.

간헐적으로 발생하는 장애에 대응하기는 좋지만, 재시도가 누적되어 오히려 시스템에 과부하를 일으킬 수 있다.

다운스트림 서비스는 순간적인 장애를 자주 겪는데, 쓰레드 풀 포화, 네트워크 접속 지연 등의 임시적 요인이 많다. 이런 임시적 요인들은 단 시간내에 복구된다. 그래서 이 다운스트림 호출을 래핑해서 재시도를 하고, 이런 일시적 오류를 대처한다.

재시도 구현에는 다음 세 가지를 고려한다.

1. 재시도의 당위성 (재시도를 하면서 중복으로 처리될 수 있지 않나?)
2. 최대 재시도 횟수 및 시간 간격
3. 고정된 응답이나 예외를 반환해야할 재시도

### 7.7.2 비율제한

갑자기 부하가 증가하면, 리소스 부담이 가중되고 SLO 이하로 가용성이 낮아질 위험이 있다.

비율제한은 호출의 비율을 제한하는 것이다. 서비스의 특성에 따라 비율 제한의 설정을 다르게하여 처리능력을 다르게 할 수 있다.

Resilience4J를 사용하고, 마이크로미터에서 비율 제한 메트릭을 게시하면, 아래와 같은 메트릭이 수집된다.

1. 가용권한 수 또는 동시 처리 여력
2. 대기 스레드 수

가용 권한이 0에 도달하거나 0에 가까워지고 있지만, 대기 쓰레드 수가 적다면 사용자 경험은 문제 없다는 것이다. 대기 쓰레드 수가 늘어난다면 최종 사용자 경험에 문제가 있다는 뜻이다.

### 7.7.3 벌크헤드

마이크로서비스는 일반적으로 여러 서비스를 의존하고 있다. 그래서 한 서비스의 가용성이 저하되어도 이를 의존하는 다른 서비스가 응답 불가 까지 갈 수 있는 위험성이 있다.

벌크헤드 패턴은 다운스트림 서비스를 서로 격리하고 각 서비스의 동시 처리 능력을 제한한다. 예를 들어 A 서비스가 B 서비스를 의존하고 있을 때, B 서비스에 장애가 발생했다면 A 서비스 에서는 그 요청은 배제하고 그 외 요청은 처리하는 방식으로 응답할 수 있다.

### 7.7.4 서킷 브레이커

서킷 브레이커도 벌크헤드 패턴과 비슷하다. 

1. 성공/실패 결과는 원형 버퍼에 보관
2. 원형 버퍼가 가득찼을 때 실패율과 임곗값을 비교
3. 실패율이 더 높을 경우 서킷 브레이커를 OPEN
4. OPEN 상태면 일정 시간동안 실행을 멈춘다
5. 대기 시간이 지나면, HALF_OPEN 상태로 바꾸고, 소량의 트래픽을 통과 시킴
6. 위의 소량의 트래픽으로 다시 실패율을 계산해서 임곗값과 비교
7. 실패율보다 낮을 경우 서킷 브레이커를 CLOSE

### 7.7.5 적응형 동시성 제한

앞에 나온 4가지 복원 패턴은 사전 예방 또는 사후 조치를 통해 부하를 방어하는 데 초점을 맞췄다.

이러한 고정된 임곗값 검증이나 수동적 선정 절차를 적응형 판단 과정으로 대체하는 것이 이 책 전체를 관통하는 주제다.

### 7.7.6 호출 복원 패턴 선정

1. 비율 제한 - 간격당 비율 제한 - 순간적인 동시성에 제한을 두지 않음(순간적으로 트래픽이 튀었다고해서 제한 하는 것이 아님)
2. 벌크헤드 - 즉각적인 동시 처리 수준 제한 - 신규 요청이 발생하는 순간 동시성 제한
3. 서킷 브레이커 - 에러 대응형 - 순간적 또는 간격당 처리 비율을 제한하지 않음

### 7.7.7 서비스 메시를 통한 구현

??

### 7.7.8 RSocket 구현

#### 리액티브 선언문에 있는 배압

> 한 컴포넌트가 부하를 이겨내기 힘들 때, [시스템](https://www.reactivemanifesto.org/ko/glossary#System) 전체가 합리적인 방법으로 대응해야 한다. 과부하 상태의 컴포넌트에서 치명적인 장애가 발생하거나 제어 없이 메시지를 유실해서는 안 된다. 컴포넌트가 대처할 수 없고 장애가 발생해선 안 되기 때문에 컴포넌트는 상류 컴포넌트들에 자신이 과부하 상태라는 것을 알려 부하를 줄이도록 해야 한다. 이러한 배압은 시스템이 부하로 인해 무너지지 않고 정상적으로 응답할 수 있게 하는 중요한 피드백 방법이다. 배압은 사용자에게까지 전달되어 응답성이 떨어질 수 있지만, 이 메커니즘은 부하에 대한 시스템의 복원력을 보장하고 시스템 자체가 부하를 분산할 다른 자원을 제공할 수 있는지 정보를 제공할 것이다.

배압을 애플리케이션 스택의 전체를 아우를 수 있다면, 인프라를 한층 더 진화 시킬 수 있다. 